{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ArxLang","text":"<p>Arx is multi-purpose compiler that aims to provide arrow datatypes as native datatypes.</p> <p>For now, it is strongly based on the Kaleidoscope compiler with a just few changes.</p> <p></p>"},{"location":"#arx-enhancement-proposals","title":"Arx Enhancement Proposals","text":"<p>Any change to the language (syntax) should be done using a Enhancement Proposal via arx-proposals repository.</p>"},{"location":"changelog/","title":"Release Notes","text":""},{"location":"changelog/#020-2025-08-07","title":"0.2.0 (2025-08-07)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fix usage of FunctionCall (#15) (f7f61c0)</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add support for blocks of nodes (#6) (1fd099f)</li> <li>Move the AST output to YAML format (#7) (6a8e10f)</li> <li>Support multiple input files (#8) (ad31064)</li> <li>Use ASTx and IRx as core libraries for AST and code generation (#14) (b730859)</li> </ul>"},{"location":"changelog/#011-2023-06-26","title":"0.1.1 (2023-06-26)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Change package name to arxlang (#2) (e30c937)</li> <li>Fix semantic release configuration (#5) (78ca1df)</li> <li>Fix the documentation issues (#3) (9ec65a3)</li> <li>Fix the semantic release workflow (#4) (b5fb75c)</li> </ul>"},{"location":"coc/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"coc/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"coc/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"coc/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"coc/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"coc/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at arxcompiler@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"coc/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"coc/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"coc/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"coc/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"coc/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"coc/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>In order to be able to contribute, it is important that you understand the project layout. This project uses the src layout, which means that the package code is located at <code>./src/arx</code>.</p> <p>For my information, check the official documentation: https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/</p> <p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/arxlang/arx/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \u201cbug\u201d and \u201chelp wanted\u201d is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \u201cenhancement\u201d and \u201chelp wanted\u201d is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>Arx could always use more documentation, whether as part of the official Arx docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/arxlang/arx/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are   welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here\u2019s how to set up <code>arx</code> for local development.</p> <ol> <li>Fork the <code>arx</code> repo on GitHub.</li> <li>Clone your fork locally:</li> </ol> <pre><code>$ git clone git@github.com:your_name_here/arx.git\n$ cd arx\n</code></pre> <ol> <li>Create the conda environment (using mamba or conda) and install the project:</li> </ol> <pre><code>$ mamba env create --file conda/dev.yaml\n$ conda activate arx\n$ poetry install\n</code></pre> <ol> <li>Create a branch for local development:</li> </ol> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <ol> <li> <p>Now you can make your changes locally.</p> </li> <li> <p>When you\u2019re done making changes, check that your changes pass the linter and    the tests:</p> </li> </ol> <pre><code>$ makim tests.linter\n$ makim tests.unit\n</code></pre> <ol> <li>Commit your changes and push your branch to GitHub:</li> </ol> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> <ol> <li>Submit a pull request through the GitHub website.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put your    new functionality into a function with a docstring, and add the feature to    the list in README.rst.</li> <li>The pull request should work for Python &gt;= 3.8.1.</li> </ol>"},{"location":"contributing/#tips","title":"Tips","text":"<p>To run a subset of tests:</p> <pre><code>$ pytest tests/test_io.py\n</code></pre>"},{"location":"contributing/#release","title":"Release","text":"<p>This project uses semantic-release in order to cut a new release based on the commit-message.</p>"},{"location":"contributing/#commit-message-format","title":"Commit message format","text":"<p>semantic-release uses the commit messages to determine the consumer impact of changes in the codebase. Following formalized conventions for commit messages, semantic-release automatically determines the next semantic version number, generates a changelog and publishes the release.</p> <p>By default, semantic-release uses Angular Commit Message Conventions. The commit message format can be changed with the <code>preset</code> or <code>config</code> options_ of the @semantic-release/commit-analyzer and @semantic-release/release-notes-generator plugins.</p> <p>Tools such as commitizen or commitlint can be used to help contributors and enforce valid commit messages.</p> <p>The table below shows which commit message gets you which release type when <code>semantic-release</code> runs (using the default configuration):</p> Commit message Release type <code>fix(pencil): stop graphite breaking when pressure is applied</code> Fix Release <code>feat(pencil): add 'graphiteWidth' option</code> Feature Release <code>perf(pencil): remove graphiteWidth option</code> Chore <code>fix(pencil)!: The graphiteWidth option has been removed</code> Breaking Release <p>source: https://github.com/semantic-release/semantic-release/blob/master/README.md#commit-message-format</p> <p>As this project uses the <code>squash and merge</code> strategy, ensure to apply the commit message format to the PR's title.</p>"},{"location":"discord/","title":"Community","text":""},{"location":"governance/","title":"Governance","text":"<p>The objectives of this document include formalizing the governance of the ArxLang (Arx) project. In both common and uncommon situations, outlining the decision-making procedure and the interactions between the various members of our community, including the relationship between work that may be supported by for-profit or nonprofit organizations and open source collaborative development.</p>"},{"location":"governance/#summary","title":"Summary","text":"<p>Arx is a community-owned and community-run project. To the maximum extent possible, decisions about project direction are made by community consensus (but note that \"consensus\" here has a somewhat technical meaning that might not match everyone's expectations -- see below). Some members of the community additionally contribute by serving on the Arx, where they are responsible for facilitating the establishment of community consensus, for stewarding project resources, and -- in extreme cases -- for making project decisions if the normal community-based process breaks down.</p>"},{"location":"governance/#the-project","title":"The project","text":"<p>ArxLang (Arx) community aims to create an open source compiler with a syntax that inherits elements from Python, C++, YAML, etc. An important aspect to Arx is that it aims to have Apache Arrow datatypes as native types.</p> <p>The Project is conducted by a distributed team of contributors, who are individuals that have collaborated with code, documentation, graphical design or other kind of work to the Project. Anyone can be a Contributor. Contributors can be affiliated with any legal entity or none. Contributors participate in the project by submitting, reviewing and discussing GitHub pull requests and issues and participating in open and public Project discussions on GitHub, discord, among other channels. The basis of project participation is openness and transparency.</p> <p>The Project Community consists of all Contributors and Users of the Project. Contributors work on behalf of and are responsible to the larger Project Community and we strive to keep the barrier between Contributors and Users as low as possible.</p> <p>In order to improve transparency and a better fiscal workflow, Arx is currently looking for a fiscal sponsor to help our project to grow.</p>"},{"location":"governance/#governance_1","title":"Governance","text":"<p>This section describes the governance and leadership model of The Project.</p> <p>The principles of Project governance are:</p> <pre><code>Openness &amp; Transparency\nActive Contribution\nInstitutional Neutrality\nDiversity, Equity and Inclusion\nEducation\n</code></pre>"},{"location":"governance/#consensus-based-decision-making-by-the-community","title":"Consensus-based decision making by the community","text":"<p>In general, all project decisions will be made by consensus of all interested Contributors. The primary goal of this approach is to ensure that the people who are most affected by and involved in any given change can contribute their knowledge in the confidence that their voices will be heard, because thoughtful review from a broad community is the best mechanism we know of for creating high-quality software.</p> <p>The mechanism we use to accomplish this goal may be unfamiliar for those who are not experienced with the cultural norms around free/open-source software development. We provide a summary here, and highly recommend that all Contributors additionally read Chapter 4: Social and Political Infrastructure of Karl Fogel's classic Producing Open Source Software, and in particular the section on Consensus-based Democracy, for a more detailed discussion.</p> <p>In this context, consensus does NOT require:</p> <ul> <li>that we wait to solicit everybody's opinion on every change,</li> <li>that we ever hold a vote on anything, or</li> <li>that everybody is happy or agrees with every decision.</li> </ul> <p>For us, what consensus means is that we entrust everyone with the right to veto any change if they feel it necessary. While this may sound like a recipe for obstruction and pain, this is not what happens. Instead, we find that most people take this responsibility seriously, and only invoke their veto when they judge that a serious problem is being ignored, and that their veto is necessary to protect the project. And in practice, it turns out that such vetoes are almost never formally invoked, because their mere possibility ensures that Contributors are motivated from the start to find some solution that everyone can live with -- thus accomplishing our goal of ensuring that all interested perspectives are taken into account.</p> <p>How do we know when consensus has been achieved? First of all, this is rather difficult since consensus is defined by the absence of vetoes, which requires us to somehow prove a negative. In practice, we use a combination of our best judgement (e.g., a simple and uncontroversial bug fix posted on GitHub and reviewed by a core developer is probably fine) and best efforts (e.g., all substantive API changes must be posted to a github issue or a discussion on discord in order to give the broader community a chance to catch any problems and suggest improvements; we assume that anyone who cares enough about Arx to invoke their veto right should be on the github Arx repositories or discord). Arx, is a small group, and aims for quick and transparent communication, so the common channels for communication are the github issues and the discord channels. So, all people involved can have a quick and transparent communication about any specific problem and we can react very quick.</p> <p>If one does need to invoke a formal veto, then the process should consist of:</p> <ul> <li>an unambiguous statement that a veto is being invoked,</li> <li>an explanation of why it is being invoked, and</li> <li>a description of what conditions (if any) would convince the vetoer to   withdraw their veto.</li> </ul> <p>If all proposals for resolving some issue are vetoed, then the status quo wins by default.</p> <p>In the worst case, if a Contributor is genuinely misusing their veto obstructively to the detriment of the project, then they can be ejected from the project by consensus of the Steering Council -- see below.</p>"},{"location":"governance/#steering-council","title":"Steering Council","text":"<p>The Project will have a Steering Council that consists of Project Contributors who have produced contributions that are substantial in quality and quantity, and sustained over at least one year. The overall role of the Council is to ensure, with input from the Community, the long-term well-being of the project, both technically and as a community.</p> <p>During the everyday project activities, council members participate in all discussions, code review and other project activities as peers with all other Contributors and the Community. In these everyday activities, Council Members do not have any special power or privilege through their membership on the Council. However, it is expected that because of the quality and quantity of their contributions and their expert knowledge of the Project Software and Services that Council Members will provide useful guidance, both technical and in terms of project direction, to potentially less experienced contributors.</p> <p>The Steering Council and its Members play a special role in certain situations. In particular, the Council may, if necessary:</p> <ul> <li>Make decisions about the overall scope, vision and direction of the project.</li> <li>Make decisions about strategic collaborations with other organizations or   individuals.</li> <li>Make decisions about specific technical issues, features, bugs and pull   requests. They are the primary mechanism of guiding the code review process   and merging pull requests.</li> <li>Make decisions about the Services that are run by The Project and manage those   Services for the benefit of the Project and Community.</li> <li>Update policy documents such as this one.</li> <li>Make decisions when regular community discussion doesn\u2019t produce consensus on   an issue in a reasonable time frame.</li> </ul> <p>However, the Council's primary responsibility is to facilitate the ordinary community-based decision making procedure described above. If we ever have to step in and formally override the community for the health of the Project, then we will do so, but we will consider reaching this point to indicate a failure in our leadership.</p>"},{"location":"governance/#council-decision-making","title":"Council decision making","text":"<p>If it becomes necessary for the Steering Council to produce a formal decision, then they will use a form of the Apache Foundation voting process. This is a formalized version of consensus, in which +1 votes indicate agreement, -1 votes are vetoes (and must be accompanied with a rationale, as above), and one can also vote fractionally (e.g. -0.5, +0.5) if one wishes to express an opinion without registering a full veto. These numeric votes are also often used informally as a way of getting a general sense of people's feelings on some issue, and should not normally be taken as formal votes. A formal vote only occurs if explicitly declared, and if this does occur then the vote should be held open for long enough to give all interested Council Members a chance to respond -- at least one week.</p> <p>In practice, we anticipate that for most Steering Council decisions (e.g., voting in new members) a more informal process will suffice.</p>"},{"location":"governance/#council-membership","title":"Council membership","text":"<p>A list of current Steering Council Members is maintained at the page About.</p> <p>To become eligible to join the Steering Council, an individual must be a Project Contributor who has produced contributions that are substantial in quality and quantity, and sustained over at least six month. Potential Council Members are nominated by existing Council members, and become members following consensus of the existing Council members, and confirmation that the potential Member is interested and willing to serve in that capacity. The Council will be initially formed from the set of existing Core Developers who, as of late 2015, have been significantly active over the last year.</p> <p>When considering potential Members, the Council will look at candidates with a comprehensive view of their contributions. This will include but is not limited to code, code review, infrastructure work, mailing list and chat participation, community help/building, education and outreach, design work, etc. We are deliberately not setting arbitrary quantitative metrics (like \u201c100 commits in this repo\u201d) to avoid encouraging behavior that plays to the metrics rather than the project\u2019s overall well-being. We want to encourage a diverse array of backgrounds, viewpoints and talents in our team, which is why we explicitly do not define code as the sole metric on which council membership will be evaluated.</p> <p>If a Council member becomes inactive in the project for a period of six month, they will be considered for removal from the Council. Before removal, inactive Member will be approached to see if they plan on returning to active participation. If not they will be removed immediately upon a Council vote. If they plan on returning to active participation soon, they will be given a grace period of one month. If they don\u2019t return to active participation within that time period they will be removed by vote of the Council without further grace period. All former Council members can be considered for membership again at any time in the future, like any other Project Contributor. Retired Council members will be listed on the project website, acknowledging the period during which they were active in the Council.</p> <p>The Council reserves the right to eject current Members, if they are deemed to be actively harmful to the project\u2019s well-being, and attempts at communication and conflict resolution have failed. This requires the consensus of the remaining Members.</p>"},{"location":"governance/#conflict-of-interest","title":"Conflict of interest","text":"<p>It is expected that the Council Members will be employed at a wide range of companies, universities and non-profit organizations. Because of this, it is possible that Members will have conflict of interests, such ones include, but are not limited to:</p> <ul> <li>Financial interests, such as investments, employment or contracting work,   outside of The Project that may influence their work on The Project.</li> <li>Access to proprietary information of their employer that could potentially   leak into their work with the Project.</li> </ul> <p>All members of the Council shall disclose to the rest of the Council any conflict of interest they may have. Members with a conflict of interest in a particular issue may participate in Council discussions on that issue, but must recuse themselves from voting on the issue.</p>"},{"location":"governance/#private-communications-of-the-council","title":"Private communications of the Council","text":"<p>To the maximum extent possible, Council discussions and activities will be public and done in collaboration and discussion with the Project Contributors and Community. The Council will have a private channel on discord that will be used sparingly and only when a specific matter requires privacy. When private communications and decisions are needed, the Council will do its best to summarize those to the Community after eliding personal/private/sensitive information that should not be posted to the public internet.</p>"},{"location":"governance/#subcommittees","title":"Subcommittees","text":"<p>The Council can create subcommittees that provide leadership and guidance for specific aspects of the project. Like the Council as a whole, subcommittees should conduct their business in an open and public manner unless privacy is specifically called for. Private subcommittee communications should happen on the main private discord channel of the Council unless specifically called for.</p>"},{"location":"governance/#institutional-partners-and-funding","title":"Institutional Partners and Funding","text":"<p>The Steering Council are the primary leadership for the project. No outside institution, individual or legal entity has the ability to own, control, usurp or influence the project other than by participating in the Project as Contributors and Council Members. However, because institutions can be an important funding mechanism for the project, it is important to formally acknowledge institutional participation in the project. These are Institutional Partners.</p> <p>An Institutional Contributor is any individual Project Contributor who contributes to the project as part of their official duties at an Institutional Partner. Likewise, an Institutional Council Member is any Project Steering Council Member who contributes to the project as part of their official duties at an Institutional Partner.</p> <p>Institutions become eligible to become an Institutional Partner when they share same values of ArxLang and are available to collaborate to the project in any of these ways:</p> <ul> <li>publicizing ArxLang in their social network</li> <li>allocate one or more contributors to help ArxLang projects</li> <li>funding ArxLang general activities</li> </ul> <p>If at some point an existing Institutional Partner doesn't accomplish with these points mentioned above, then six month grace period begins. If at the end of this six months period they continue not to have any contribution, then their Institutional Partnership will lapse, and resuming it will require going through the normal process for new Partnerships.</p> <p>Funding acquired by Institutional Partners to work on The Project is called Institutional Funding. However, no funding obtained by an Institutional Partner can override the Steering Council. If a Partner has funding to do Open Science work and the Council decides to not pursue that work as a project, the Partner is free to pursue it on their own. However in this situation, that part of the Partner\u2019s work will not be under the ArxLang umbrella and cannot use the Project trademarks in a way that suggests a formal relationship.</p> <p>Institutional Partner benefits are:</p> <ul> <li>Acknowledgement on the ArxLang websites and in talks.</li> <li>Ability to influence the project through the participation of their Council   Member.</li> <li>Council Members invited to ArxLang Developer Meetings.</li> </ul> <p>A list of current Institutional Partners is maintained at the page About Us.</p>"},{"location":"governance/#document-history","title":"Document history","text":"<ul> <li>arxlang/arx</li> </ul>"},{"location":"governance/#acknowledgements","title":"Acknowledgements","text":"<p>Substantial portions of this document were adapted from the Open Science Labs project governance and decision-making document https://github.com/OpenScienceLabs/opensciencelabs.github.io/blob/main/pages/governance.md.</p> <p>Additionally, the Open Science Labs project governance is based on the Numpy project governance file: https://github.com/numpy/numpy/commits/main/doc/source/dev/governance/governance.rst.</p>"},{"location":"governance/#license","title":"License","text":"<p>CC BY-SA 4.0: https://creativecommons.org/licenses/by-sa/4.0/</p>"},{"location":"partners/","title":"Partners","text":"<p>           Open science labs is a community that aims to gather people from all parts of the world, specially from latin america countries and create an open space for teaching, learning and sharing topics around open science and computational tools. An english group is very important in this context because it increases the possibilities of collaboration in open projects.         </p> <p> </p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>The roadmap document define the direction that the project is taking.</p> <p>The initial and decisive part of the project is the implementation of the Apache Arrow datatypes as the native datatypes. But in order to get to the point where we can implement that, we need first implement a bunch of small pieces to the compiler, in all the phases: lexer, parser, semantic analysis, and code generator.</p>"},{"location":"roadmap/#improve-the-language-structure","title":"Improve the language structure","text":"<ul> <li>[ ] Currently, almost everything is a expression, but some structure should be       converted to statements.</li> <li>[ ] <code>For</code> loop</li> <li>[ ] <code>If</code></li> <li>[ ] Implement <code>return</code> keyword</li> <li>[ ] Allow multiple lines in a block</li> <li>[ ] Add support for <code>while</code> loop</li> <li>[ ] Add support for <code>switch</code></li> <li>[ ] Add support for code structure defined by indentation</li> <li>[ ] Add support packaging and <code>import</code></li> <li>[ ] Add support for <code>docstring</code></li> <li>[x] Add support for file objects generation</li> <li>[ ] Add support for generating executable files</li> <li>[ ] Add support for mutable variables</li> <li>[ ] Add support for classes (details TBA)</li> </ul>"},{"location":"roadmap/#data-type-support","title":"Data type support","text":"<p>ArxLang is based on Kaleidoscope compiler, so it just implements float data type for now.</p> <p>In order to accept more datatypes, the language should have a way to specify the type for each variable and function returning.</p> <ul> <li>[x] Wave 1: float32</li> <li>[ ] Wave 2: static typing</li> <li>[ ] Wave 3: int8, int16, int32, int64</li> <li>[ ] Wave 4: float16, float64</li> <li>[ ] Wave 5: string</li> <li>[ ] Wave 6: datetime</li> </ul>"},{"location":"roadmap/#implement-apache-arrow-datatypes","title":"Implement Apache Arrow datatypes","text":"<p>TBA</p>"},{"location":"sponsor/","title":"Sponsor","text":""},{"location":"api/","title":"Index","text":""},{"location":"api/#arx","title":"arx","text":"<p>Arx is a compiler create with llvm.</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Functions and classes for handling the CLI call.</p> </li> <li> <code>exceptions</code>           \u2013            <p>Define custom Exceptions to improve error message.</p> </li> <li> <code>io</code>           \u2013            <p>Module for handling the IO used by the compiler.</p> </li> <li> <code>lexer</code>           \u2013            <p>Module for handling the lexer analysis.</p> </li> <li> <code>logs</code>           \u2013            <p>The logs functions and classes handle all the system messages.</p> </li> <li> <code>main</code>           \u2013            <p>Arx main module.</p> </li> <li> <code>parser</code>           \u2013            <p>parser module gather all functions and classes for parsing.</p> </li> <li> <code>semantic</code>           \u2013            <p>Semantic analysis module.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_version</code>             \u2013              <p>Return the program version.</p> </li> </ul>"},{"location":"api/#arx.get_version","title":"get_version","text":"<pre><code>get_version() -&gt; str\n</code></pre> <p>Return the program version.</p> Source code in <code>src/arx/__init__.py</code> <pre><code>def get_version() -&gt; str:\n    \"\"\"Return the program version.\"\"\"\n    try:\n        return importlib_metadata.version(__name__)\n    except importlib_metadata.PackageNotFoundError:  # pragma: no cover\n        return \"0.2.0\"  # semantic-release\n</code></pre>"},{"location":"api/SUMMARY/","title":"SUMMARY","text":"<ul> <li> arx<ul> <li> cli</li> <li> exceptions</li> <li> io</li> <li> lexer</li> <li> logs</li> <li> main</li> <li> parser</li> <li> semantic</li> </ul> </li> </ul>"},{"location":"api/cli/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> cli","text":""},{"location":"api/cli/#arx.cli","title":"cli","text":"<p>Functions and classes for handling the CLI call.</p> <p>Classes:</p> <ul> <li> <code>CustomHelpFormatter</code>           \u2013            <p>Formatter for generating usage messages and argument help strings.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>app</code>             \u2013              <p>Run the application.</p> </li> <li> <code>get_args</code>             \u2013              <p>Get the CLI arguments.</p> </li> <li> <code>show_version</code>             \u2013              <p>Show the application version.</p> </li> </ul>"},{"location":"api/cli/#arx.cli.CustomHelpFormatter","title":"CustomHelpFormatter","text":"<pre><code>CustomHelpFormatter(\n    prog: str,\n    indent_increment: int = 2,\n    max_help_position: int = 4,\n    width: Optional[int] = None,\n    **kwargs: Any,\n)\n</code></pre> <p>               Bases: <code>RawTextHelpFormatter</code></p> <p>Formatter for generating usage messages and argument help strings.</p> <p>Only the name of this class is considered a public API. All the methods provided by the class are considered an implementation detail.</p> Source code in <code>src/arx/cli.py</code> <pre><code>def __init__(\n    self,\n    prog: str,\n    indent_increment: int = 2,\n    max_help_position: int = 4,\n    width: Optional[int] = None,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        prog,\n        indent_increment=indent_increment,\n        max_help_position=max_help_position,\n        width=width,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/cli/#arx.cli.app","title":"app","text":"<pre><code>app() -&gt; None\n</code></pre> <p>Run the application.</p> Source code in <code>src/arx/cli.py</code> <pre><code>def app() -&gt; None:\n    \"\"\"Run the application.\"\"\"\n    args_parser = get_args()\n    args = args_parser.parse_args()\n\n    if args.version:\n        return show_version()\n\n    arx = ArxMain()\n    return arx.run(**dict(args._get_kwargs()))\n</code></pre>"},{"location":"api/cli/#arx.cli.get_args","title":"get_args","text":"<pre><code>get_args() -&gt; ArgumentParser\n</code></pre> <p>Get the CLI arguments.</p> Source code in <code>src/arx/cli.py</code> <pre><code>def get_args() -&gt; argparse.ArgumentParser:\n    \"\"\"Get the CLI arguments.\"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"arx\",\n        description=(\n            \"Arx is a compiler that uses the power of llvm to bring a modern \"\n            \"infra-structure.\"\n        ),\n        epilog=(\n            \"If you have any problem, open an issue at: \"\n            \"https://github.com/arxlang/arx\"\n        ),\n        add_help=True,\n        formatter_class=CustomHelpFormatter,\n    )\n    parser.add_argument(\n        \"input_files\",\n        nargs=\"*\",\n        type=str,\n        help=\"The input file\",\n    )\n    parser.add_argument(\n        \"--version\",\n        action=\"store_true\",\n        help=\"Show the version of the installed MakIm tool.\",\n    )\n\n    parser.add_argument(\n        \"--output-file\",\n        type=str,\n        help=\"The output file\",\n    )\n\n    parser.add_argument(\n        \"--lib\",\n        dest=\"is_lib\",\n        action=\"store_true\",\n        help=\"build source code as library\",\n    )\n\n    parser.add_argument(\n        \"--show-ast\",\n        action=\"store_true\",\n        help=\"Show the AST for the input source code\",\n    )\n\n    parser.add_argument(\n        \"--show-tokens\",\n        action=\"store_true\",\n        help=\"Show the tokens for the input source code\",\n    )\n\n    parser.add_argument(\n        \"--show-llvm-ir\",\n        action=\"store_true\",\n        help=\"Show the LLVM IR for the input source code\",\n    )\n\n    parser.add_argument(\n        \"--shell\",\n        action=\"store_true\",\n        help=\"Open Arx in a shell prompt\",\n    )\n\n    return parser\n</code></pre>"},{"location":"api/cli/#arx.cli.show_version","title":"show_version","text":"<pre><code>show_version() -&gt; None\n</code></pre> <p>Show the application version.</p> Source code in <code>src/arx/cli.py</code> <pre><code>def show_version() -&gt; None:\n    \"\"\"Show the application version.\"\"\"\n    print(__version__)\n</code></pre>"},{"location":"api/exceptions/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> exceptions","text":""},{"location":"api/exceptions/#arx.exceptions","title":"exceptions","text":"<p>Define custom Exceptions to improve error message.</p> <p>Classes:</p> <ul> <li> <code>CodeGenException</code>           \u2013            <p>Handle exceptions for the CodeGen phase.</p> </li> <li> <code>ParserException</code>           \u2013            <p>Handle exceptions for the Parser phase.</p> </li> </ul>"},{"location":"api/exceptions/#arx.exceptions.CodeGenException","title":"CodeGenException","text":"<pre><code>CodeGenException(message: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Handle exceptions for the CodeGen phase.</p> Source code in <code>src/arx/exceptions.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize ParserException.\"\"\"\n    super().__init__(f\"CodeGenError: {message}\")\n</code></pre>"},{"location":"api/exceptions/#arx.exceptions.ParserException","title":"ParserException","text":"<pre><code>ParserException(message: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Handle exceptions for the Parser phase.</p> Source code in <code>src/arx/exceptions.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    \"\"\"Initialize ParserException.\"\"\"\n    super().__init__(f\"ParserError: {message}\")\n</code></pre>"},{"location":"api/io/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> io","text":""},{"location":"api/io/#arx.io","title":"io","text":"<p>Module for handling the IO used by the compiler.</p> <p>Classes:</p> <ul> <li> <code>ArxBuffer</code>           \u2013            <p>ArxBuffer gathers function for handle the system buffer.</p> </li> <li> <code>ArxFile</code>           \u2013            <p>ArxFile gathers function to handle files.</p> </li> <li> <code>ArxIO</code>           \u2013            <p>Arx class for Input and Output operations.</p> </li> </ul>"},{"location":"api/io/#arx.io.ArxBuffer","title":"ArxBuffer","text":"<pre><code>ArxBuffer()\n</code></pre> <p>ArxBuffer gathers function for handle the system buffer.</p> <p>Methods:</p> <ul> <li> <code>clean</code>             \u2013              <p>Clean the buffer content.</p> </li> <li> <code>read</code>             \u2013              <p>Read the buffer content.</p> </li> <li> <code>write</code>             \u2013              <p>Write the given text to the buffer.</p> </li> </ul> Source code in <code>src/arx/io.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize ArxBuffer instance.\"\"\"\n    self.clean()\n</code></pre>"},{"location":"api/io/#arx.io.ArxBuffer.clean","title":"clean","text":"<pre><code>clean() -&gt; None\n</code></pre> <p>Clean the buffer content.</p> Source code in <code>src/arx/io.py</code> <pre><code>def clean(self) -&gt; None:\n    \"\"\"Clean the buffer content.\"\"\"\n    self.position = 0\n    self.buffer = \"\"\n</code></pre>"},{"location":"api/io/#arx.io.ArxBuffer.read","title":"read","text":"<pre><code>read() -&gt; str\n</code></pre> <p>Read the buffer content.</p> Source code in <code>src/arx/io.py</code> <pre><code>def read(self) -&gt; str:\n    \"\"\"Read the buffer content.\"\"\"\n    try:\n        i = self.position\n        self.position += 1\n        return self.buffer[i]\n    except IndexError:\n        return \"\"\n</code></pre>"},{"location":"api/io/#arx.io.ArxBuffer.write","title":"write","text":"<pre><code>write(text: str) -&gt; None\n</code></pre> <p>Write the given text to the buffer.</p> Source code in <code>src/arx/io.py</code> <pre><code>def write(self, text: str) -&gt; None:\n    \"\"\"Write the given text to the buffer.\"\"\"\n    self.buffer += text\n    self.position = 0\n</code></pre>"},{"location":"api/io/#arx.io.ArxFile","title":"ArxFile","text":"<p>ArxFile gathers function to handle files.</p> <p>Methods:</p> <ul> <li> <code>create_tmp_file</code>             \u2013              <p>Create a temporary file with the given content.</p> </li> <li> <code>delete_file</code>             \u2013              <p>Delete the specified file.</p> </li> </ul>"},{"location":"api/io/#arx.io.ArxFile.create_tmp_file","title":"create_tmp_file  <code>staticmethod</code>","text":"<pre><code>create_tmp_file(content: str) -&gt; str\n</code></pre> <p>Create a temporary file with the given content.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>str</code>)           \u2013            <p>The content of the temporary file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The name of the created temporary file.</p> </li> </ul> Source code in <code>src/arx/io.py</code> <pre><code>@staticmethod\ndef create_tmp_file(content: str) -&gt; str:\n    \"\"\"\n    Create a temporary file with the given content.\n\n    Parameters\n    ----------\n    content : str\n        The content of the temporary file.\n\n    Returns\n    -------\n    str\n        The name of the created temporary file.\n    \"\"\"\n    # Create a temporary file.\n    with tempfile.NamedTemporaryFile(delete=False) as tmpfile:\n        tmpfile.write(content.encode())\n\n    # Rename the temporary file with the .cpp extension.\n    filename = tmpfile.name\n    filename_ext = filename + \".cpp\"\n    os.rename(filename, filename_ext)\n\n    return filename_ext\n</code></pre>"},{"location":"api/io/#arx.io.ArxFile.delete_file","title":"delete_file  <code>staticmethod</code>","text":"<pre><code>delete_file(filename: str) -&gt; int\n</code></pre> <p>Delete the specified file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>The name of the file to be deleted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Returns 0 on success, or -1 on failure.</p> </li> </ul> Source code in <code>src/arx/io.py</code> <pre><code>@staticmethod\ndef delete_file(filename: str) -&gt; int:\n    \"\"\"\n    Delete the specified file.\n\n    Parameters\n    ----------\n    filename : str\n        The name of the file to be deleted.\n\n    Returns\n    -------\n    int\n        Returns 0 on success, or -1 on failure.\n    \"\"\"\n    try:\n        os.remove(filename)\n        return 0\n    except OSError:\n        return -1\n</code></pre>"},{"location":"api/io/#arx.io.ArxIO","title":"ArxIO","text":"<p>Arx class for Input and Output operations.</p> <p>Methods:</p> <ul> <li> <code>file_to_buffer</code>             \u2013              <p>Copy the file content to the buffer.</p> </li> <li> <code>get_char</code>             \u2013              <p>Get a char from the buffer or from the default input.</p> </li> <li> <code>load_input_to_buffer</code>             \u2013              <p>Load the content file or the standard input to the buffer.</p> </li> <li> <code>string_to_buffer</code>             \u2013              <p>Copy the given string to the buffer.</p> </li> </ul>"},{"location":"api/io/#arx.io.ArxIO.file_to_buffer","title":"file_to_buffer  <code>classmethod</code>","text":"<pre><code>file_to_buffer(filename: str) -&gt; None\n</code></pre> <p>Copy the file content to the buffer.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>The name of the file to be copied to the buffer.</p> </li> </ul> Source code in <code>src/arx/io.py</code> <pre><code>@classmethod\ndef file_to_buffer(cls, filename: str) -&gt; None:\n    \"\"\"\n    Copy the file content to the buffer.\n\n    Parameters\n    ----------\n    filename : str\n        The name of the file to be copied to the buffer.\n    \"\"\"\n    with open(filename, \"r\") as arxfile:\n        cls.buffer.clean()\n        for line in arxfile:\n            cls.buffer.write(line + \"\\n\")\n</code></pre>"},{"location":"api/io/#arx.io.ArxIO.get_char","title":"get_char  <code>classmethod</code>","text":"<pre><code>get_char() -&gt; str\n</code></pre> <p>Get a char from the buffer or from the default input.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A char from the buffer.</p> </li> </ul> Source code in <code>src/arx/io.py</code> <pre><code>@classmethod\ndef get_char(cls) -&gt; str:\n    \"\"\"\n    Get a char from the buffer or from the default input.\n\n    Returns\n    -------\n    str\n        A char from the buffer.\n    \"\"\"\n    if cls.INPUT_FROM_STDIN:\n        return sys.stdin.read(1)\n    return cls.buffer.read()\n</code></pre>"},{"location":"api/io/#arx.io.ArxIO.load_input_to_buffer","title":"load_input_to_buffer  <code>classmethod</code>","text":"<pre><code>load_input_to_buffer() -&gt; None\n</code></pre> <p>Load the content file or the standard input to the buffer.</p> Source code in <code>src/arx/io.py</code> <pre><code>@classmethod\ndef load_input_to_buffer(cls) -&gt; None:\n    \"\"\"Load the content file or the standard input to the buffer.\"\"\"\n    if cls.INPUT_FILE:\n        input_file_path = os.path.abspath(cls.INPUT_FILE)\n        cls.file_to_buffer(input_file_path)\n        return\n\n    file_content = sys.stdin.read().strip()\n    if file_content:\n        cls.string_to_buffer(file_content)\n</code></pre>"},{"location":"api/io/#arx.io.ArxIO.string_to_buffer","title":"string_to_buffer  <code>classmethod</code>","text":"<pre><code>string_to_buffer(value: str) -&gt; None\n</code></pre> <p>Copy the given string to the buffer.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>str</code>)           \u2013            <p>The string to be copied to the buffer.</p> </li> </ul> Source code in <code>src/arx/io.py</code> <pre><code>@classmethod\ndef string_to_buffer(cls, value: str) -&gt; None:\n    \"\"\"\n    Copy the given string to the buffer.\n\n    Parameters\n    ----------\n    value : str\n        The string to be copied to the buffer.\n    \"\"\"\n    cls.buffer.clean()\n    cls.buffer.write(value)\n</code></pre>"},{"location":"api/lexer/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> lexer","text":""},{"location":"api/lexer/#arx.lexer","title":"lexer","text":"<p>Module for handling the lexer analysis.</p> <p>Classes:</p> <ul> <li> <code>Lexer</code>           \u2013            <p>Lexer class for tokenizing known variables.</p> </li> <li> <code>Token</code>           \u2013            <p>Token class store the kind and the value of the token.</p> </li> <li> <code>TokenKind</code>           \u2013            <p>TokenKind enumeration for known variables returned by the lexer.</p> </li> <li> <code>TokenList</code>           \u2013            <p>Class for handle a List of tokens.</p> </li> </ul>"},{"location":"api/lexer/#arx.lexer.Lexer","title":"Lexer","text":"<pre><code>Lexer()\n</code></pre> <p>Lexer class for tokenizing known variables.</p> <p>Attributes:</p> <ul> <li> <code>cur_loc</code>               (<code>SourceLocation</code>)           \u2013            <p>Current source location.</p> </li> <li> <code>lex_loc</code>               (<code>SourceLocation</code>)           \u2013            <p>Source location for lexer.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>advance</code>             \u2013              <p>Advance the token from the buffer.</p> </li> <li> <code>clean</code>             \u2013              <p>Reset the Lexer attributes.</p> </li> <li> <code>get_token</code>             \u2013              <p>Get the next token.</p> </li> <li> <code>lex</code>             \u2013              <p>Create a list of tokens from input source.</p> </li> </ul> Source code in <code>src/arx/lexer.py</code> <pre><code>def __init__(self) -&gt; None:\n    # self.cur_loc: SourceLocation = SourceLocation(0, 0)\n    self.lex_loc: SourceLocation = SourceLocation(0, 0)\n    self.last_char: str = \"\"\n    self.new_line: bool = True\n\n    self._keyword_map: Dict[str, TokenKind] = copy.deepcopy(\n        self._keyword_map\n    )\n</code></pre>"},{"location":"api/lexer/#arx.lexer.Lexer.advance","title":"advance","text":"<pre><code>advance() -&gt; str\n</code></pre> <p>Advance the token from the buffer.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>TokenKind in integer form.</p> </li> </ul> Source code in <code>src/arx/lexer.py</code> <pre><code>def advance(self) -&gt; str:\n    \"\"\"\n    Advance the token from the buffer.\n\n    Returns\n    -------\n    int\n        TokenKind in integer form.\n    \"\"\"\n    last_char = ArxIO.get_char()\n\n    if last_char in (\"\\n\", \"\\r\"):\n        self.lex_loc.line += 1\n        self.lex_loc.col = 0\n    else:\n        self.lex_loc.col += 1\n\n    return last_char\n</code></pre>"},{"location":"api/lexer/#arx.lexer.Lexer.clean","title":"clean","text":"<pre><code>clean() -&gt; None\n</code></pre> <p>Reset the Lexer attributes.</p> Source code in <code>src/arx/lexer.py</code> <pre><code>def clean(self) -&gt; None:\n    \"\"\"Reset the Lexer attributes.\"\"\"\n    # self.cur_loc = SourceLocation(0, 0)\n    self.lex_loc = SourceLocation(0, 0)\n    self.last_char = \"\"\n    self.new_line = True\n</code></pre>"},{"location":"api/lexer/#arx.lexer.Lexer.get_token","title":"get_token","text":"<pre><code>get_token() -&gt; Token\n</code></pre> <p>Get the next token.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The next token from standard input.</p> </li> </ul> Source code in <code>src/arx/lexer.py</code> <pre><code>def get_token(self) -&gt; Token:\n    \"\"\"\n    Get the next token.\n\n    Returns\n    -------\n    int\n        The next token from standard input.\n    \"\"\"\n    if self.last_char == \"\":\n        self.new_line = True\n        self.last_char = self.advance()\n\n    # Skip any whitespace.\n    indent = 0\n    while self.last_char.isspace():\n        if self.new_line:\n            indent += 1\n\n        if self.last_char == \"\\n\":\n            # note: if it is an empty line it is not necessary to keep\n            #       the record about the indentation\n            self.new_line = True\n            indent = 0\n\n        self.last_char = self.advance()\n\n    self.new_line = False\n\n    if indent:\n        return Token(\n            kind=TokenKind.indent, value=indent, location=self.lex_loc\n        )\n\n    # self.cur_loc = self.lex_loc\n\n    if self.last_char.isalpha() or self.last_char == \"_\":\n        # Identifier\n        identifier = self.last_char\n        self.last_char = self.advance()\n\n        while self.last_char.isalnum() or self.last_char == \"_\":\n            identifier += self.last_char\n            self.last_char = self.advance()\n\n        if identifier in self._keyword_map:\n            return Token(\n                kind=self._keyword_map[identifier],\n                value=identifier,\n                location=self.lex_loc,\n            )\n\n        return Token(\n            kind=TokenKind.identifier,\n            value=identifier,\n            location=self.lex_loc,\n        )\n\n    # Number: [0-9.]+\n    if self.last_char.isdigit() or self.last_char == \".\":\n        num_str = \"\"\n        while self.last_char.isdigit() or self.last_char == \".\":\n            num_str += self.last_char\n            self.last_char = self.advance()\n\n        return Token(\n            kind=TokenKind.float_literal,\n            value=float(num_str),\n            location=self.lex_loc,\n        )\n\n    # Comment until end of line.\n    if self.last_char == \"#\":\n        while self.last_char not in (EOF, \"\\n\", \"\\r\"):\n            self.last_char = self.advance()\n\n        if self.last_char != EOF:\n            return self.get_token()\n\n    # Check for end of file. Don't eat the EOF.\n    if self.last_char:\n        this_char = self.last_char\n        self.last_char = self.advance()\n        return Token(\n            kind=TokenKind.operator, value=this_char, location=self.lex_loc\n        )\n    return Token(kind=TokenKind.eof, value=\"\", location=self.lex_loc)\n</code></pre>"},{"location":"api/lexer/#arx.lexer.Lexer.lex","title":"lex","text":"<pre><code>lex() -&gt; TokenList\n</code></pre> <p>Create a list of tokens from input source.</p> Source code in <code>src/arx/lexer.py</code> <pre><code>def lex(self) -&gt; TokenList:\n    \"\"\"Create a list of tokens from input source.\"\"\"\n    self.clean()\n    cur_tok = Token(kind=TokenKind.not_initialized, value=\"\")\n    tokens: List[Token] = []\n    while cur_tok.kind != TokenKind.eof:\n        cur_tok = self.get_token()\n        tokens.append(cur_tok)\n    return TokenList(tokens)\n</code></pre>"},{"location":"api/lexer/#arx.lexer.Token","title":"Token  <code>dataclass</code>","text":"<pre><code>Token(\n    kind: TokenKind,\n    value: Any,\n    location: SourceLocation = SourceLocation(0, 0),\n)\n</code></pre> <p>Token class store the kind and the value of the token.</p> <p>Methods:</p> <ul> <li> <code>get_display_value</code>             \u2013              <p>Return the string representation of a token value.</p> </li> <li> <code>get_name</code>             \u2013              <p>Get the name of the specified token.</p> </li> </ul> Source code in <code>src/arx/lexer.py</code> <pre><code>def __init__(\n    self,\n    kind: TokenKind,\n    value: Any,\n    location: SourceLocation = SourceLocation(0, 0),\n) -&gt; None:\n    self.kind = kind\n    self.value = value\n    self.location = copy.deepcopy(location)\n</code></pre>"},{"location":"api/lexer/#arx.lexer.Token.get_display_value","title":"get_display_value","text":"<pre><code>get_display_value() -&gt; str\n</code></pre> <p>Return the string representation of a token value.</p> <p>Returns:</p> <ul> <li> <code>    str: The string representation of the token value.</code>           \u2013            </li> </ul> Source code in <code>src/arx/lexer.py</code> <pre><code>def get_display_value(self) -&gt; str:\n    \"\"\"\n    Return the string representation of a token value.\n\n    Returns\n    -------\n        str: The string representation of the token value.\n    \"\"\"\n    if self.kind == TokenKind.identifier:\n        return \"(\" + str(self.value) + \")\"\n    if self.kind == TokenKind.indent:\n        return \"(\" + str(self.value) + \")\"\n    elif self.kind == TokenKind.float_literal:\n        return \"(\" + str(self.value) + \")\"\n    return \"\"\n</code></pre>"},{"location":"api/lexer/#arx.lexer.Token.get_name","title":"get_name","text":"<pre><code>get_name() -&gt; str\n</code></pre> <p>Get the name of the specified token.</p> <p>Parameters:</p> <ul> <li> <code>tok</code>               (<code>int</code>)           \u2013            <p>TokenKind value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Name of the token.</p> </li> </ul> Source code in <code>src/arx/lexer.py</code> <pre><code>def get_name(self) -&gt; str:\n    \"\"\"\n    Get the name of the specified token.\n\n    Parameters\n    ----------\n    tok : int\n        TokenKind value.\n\n    Returns\n    -------\n    str\n        Name of the token.\n    \"\"\"\n    return MAP_KW_TOKEN_TO_NAME.get(self.kind, str(self.value))\n</code></pre>"},{"location":"api/lexer/#arx.lexer.TokenKind","title":"TokenKind","text":"<p>               Bases: <code>Enum</code></p> <p>TokenKind enumeration for known variables returned by the lexer.</p>"},{"location":"api/lexer/#arx.lexer.TokenList","title":"TokenList","text":"<pre><code>TokenList(tokens: List[Token])\n</code></pre> <p>Class for handle a List of tokens.</p> <p>Methods:</p> <ul> <li> <code>get_next_token</code>             \u2013              <p>Provide a simple token buffer.</p> </li> <li> <code>get_token</code>             \u2013              <p>Get the next token.</p> </li> </ul> Source code in <code>src/arx/lexer.py</code> <pre><code>def __init__(self, tokens: List[Token]) -&gt; None:\n    \"\"\"Instantiate a TokenList object.\"\"\"\n    self.tokens = tokens\n    self.position = 0\n    self.cur_tok: Token = Token(kind=TokenKind.not_initialized, value=\"\")\n</code></pre>"},{"location":"api/lexer/#arx.lexer.TokenList.get_next_token","title":"get_next_token","text":"<pre><code>get_next_token() -&gt; Token\n</code></pre> <p>Provide a simple token buffer.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The current token the parser is looking at. Reads another token from the lexer and updates cur_tok with its results.</p> </li> </ul> Source code in <code>src/arx/lexer.py</code> <pre><code>def get_next_token(self) -&gt; Token:\n    \"\"\"\n    Provide a simple token buffer.\n\n    Returns\n    -------\n    int\n        The current token the parser is looking at.\n        Reads another token from the lexer and updates\n        cur_tok with its results.\n    \"\"\"\n    self.cur_tok = self.get_token()\n    return self.cur_tok\n</code></pre>"},{"location":"api/lexer/#arx.lexer.TokenList.get_token","title":"get_token","text":"<pre><code>get_token() -&gt; Token\n</code></pre> <p>Get the next token.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The next token from standard input.</p> </li> </ul> Source code in <code>src/arx/lexer.py</code> <pre><code>def get_token(self) -&gt; Token:\n    \"\"\"\n    Get the next token.\n\n    Returns\n    -------\n    int\n        The next token from standard input.\n    \"\"\"\n    tok = self.tokens[self.position]\n    self.position += 1\n    return tok\n</code></pre>"},{"location":"api/logs/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> logs","text":""},{"location":"api/logs/#arx.logs","title":"logs","text":"<p>The logs functions and classes handle all the system messages.</p> <p>Functions:</p> <ul> <li> <code>LogError</code>             \u2013              <p>LogError - A helper function for error handling.</p> </li> </ul>"},{"location":"api/logs/#arx.logs.LogError","title":"LogError","text":"<pre><code>LogError(message: str) -&gt; None\n</code></pre> <p>LogError - A helper function for error handling.</p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>The error message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Returns None as an error indicator.</p> </li> </ul> Source code in <code>src/arx/logs.py</code> <pre><code>def LogError(message: str) -&gt; None:\n    \"\"\"\n    LogError - A helper function for error handling.\n\n    Parameters\n    ----------\n    message : str\n        The error message.\n\n    Returns\n    -------\n    None\n        Returns None as an error indicator.\n    \"\"\"\n    print(f\"Error: {message}\\n\", file=sys.stderr)\n</code></pre>"},{"location":"api/main/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> main","text":""},{"location":"api/main/#arx.main","title":"main","text":"<p>Arx main module.</p> <p>Classes:</p> <ul> <li> <code>ArxMain</code>           \u2013            <p>The main class for calling Arx compiler.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_module_name_from_file_path</code>             \u2013              <p>Return the module name from the source file name.</p> </li> </ul>"},{"location":"api/main/#arx.main.ArxMain","title":"ArxMain  <code>dataclass</code>","text":"<pre><code>ArxMain(\n    input_files: list[str] = list(),\n    output_file: str = \"\",\n    is_lib: bool = False,\n)\n</code></pre> <p>The main class for calling Arx compiler.</p> <p>Methods:</p> <ul> <li> <code>compile</code>             \u2013              <p>Compile the given input file.</p> </li> <li> <code>run</code>             \u2013              <p>Compile the given source code.</p> </li> <li> <code>run_shell</code>             \u2013              <p>Open arx in shell mode.</p> </li> <li> <code>show_ast</code>             \u2013              <p>Print the AST for the given input file.</p> </li> <li> <code>show_llvm_ir</code>             \u2013              <p>Compile into LLVM IR the given input file.</p> </li> <li> <code>show_tokens</code>             \u2013              <p>Print the AST for the given input file.</p> </li> </ul>"},{"location":"api/main/#arx.main.ArxMain.compile","title":"compile","text":"<pre><code>compile(show_llvm_ir: bool = False) -&gt; None\n</code></pre> <p>Compile the given input file.</p> Source code in <code>src/arx/main.py</code> <pre><code>def compile(self, show_llvm_ir: bool = False) -&gt; None:\n    \"\"\"Compile the given input file.\"\"\"\n    tree_ast = self._get_astx()\n    ir = LLVMLiteIR()\n    ir.build(tree_ast, output_file=self.output_file)\n</code></pre>"},{"location":"api/main/#arx.main.ArxMain.run","title":"run","text":"<pre><code>run(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Compile the given source code.</p> Source code in <code>src/arx/main.py</code> <pre><code>def run(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"Compile the given source code.\"\"\"\n    self.input_files = kwargs.get(\"input_files\", [])\n    self.output_file = kwargs.get(\"output_file\", \"\")\n    # is_lib now is the only available option\n    self.is_lib = kwargs.get(\"is_lib\", True) or True\n\n    if kwargs.get(\"show_ast\"):\n        return self.show_ast()\n\n    if kwargs.get(\"show_tokens\"):\n        return self.show_tokens()\n\n    if kwargs.get(\"show_llvm_ir\"):\n        return self.show_llvm_ir()\n\n    if kwargs.get(\"shell\"):\n        return self.run_shell()\n\n    self.compile()\n</code></pre>"},{"location":"api/main/#arx.main.ArxMain.run_shell","title":"run_shell","text":"<pre><code>run_shell() -&gt; None\n</code></pre> <p>Open arx in shell mode.</p> Source code in <code>src/arx/main.py</code> <pre><code>def run_shell(self) -&gt; None:\n    \"\"\"Open arx in shell mode.\"\"\"\n    raise Exception(\"Arx Shell is not implemented yet.\")\n</code></pre>"},{"location":"api/main/#arx.main.ArxMain.show_ast","title":"show_ast","text":"<pre><code>show_ast() -&gt; None\n</code></pre> <p>Print the AST for the given input file.</p> Source code in <code>src/arx/main.py</code> <pre><code>def show_ast(self) -&gt; None:\n    \"\"\"Print the AST for the given input file.\"\"\"\n    tree_ast = self._get_astx()\n    print(repr(tree_ast))\n</code></pre>"},{"location":"api/main/#arx.main.ArxMain.show_llvm_ir","title":"show_llvm_ir","text":"<pre><code>show_llvm_ir() -&gt; None\n</code></pre> <p>Compile into LLVM IR the given input file.</p> Source code in <code>src/arx/main.py</code> <pre><code>def show_llvm_ir(self) -&gt; None:\n    \"\"\"Compile into LLVM IR the given input file.\"\"\"\n    tree_ast = self._get_astx()\n    ir = LLVMLiteIR()\n    print(ir.translator.translate(tree_ast))\n</code></pre>"},{"location":"api/main/#arx.main.ArxMain.show_tokens","title":"show_tokens","text":"<pre><code>show_tokens() -&gt; None\n</code></pre> <p>Print the AST for the given input file.</p> Source code in <code>src/arx/main.py</code> <pre><code>def show_tokens(self) -&gt; None:\n    \"\"\"Print the AST for the given input file.\"\"\"\n    lexer = Lexer()\n\n    for input_file in self.input_files:\n        ArxIO.file_to_buffer(input_file)\n        tokens = lexer.lex()\n        for token in tokens:\n            print(token)\n</code></pre>"},{"location":"api/main/#arx.main.get_module_name_from_file_path","title":"get_module_name_from_file_path","text":"<pre><code>get_module_name_from_file_path(filepath: str) -&gt; str\n</code></pre> <p>Return the module name from the source file name.</p> Source code in <code>src/arx/main.py</code> <pre><code>def get_module_name_from_file_path(filepath: str) -&gt; str:\n    \"\"\"Return the module name from the source file name.\"\"\"\n    return filepath.split(os.sep)[-1].replace(\".arx\", \"\")\n</code></pre>"},{"location":"api/parser/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> parser","text":""},{"location":"api/parser/#arx.parser","title":"parser","text":"<p>parser module gather all functions and classes for parsing.</p> <p>Classes:</p> <ul> <li> <code>Parser</code>           \u2013            <p>Parser class.</p> </li> </ul>"},{"location":"api/parser/#arx.parser.Parser","title":"Parser","text":"<pre><code>Parser(tokens: TokenList = TokenList([]))\n</code></pre> <p>Parser class.</p> <p>Methods:</p> <ul> <li> <code>clean</code>             \u2013              <p>Reset the Parser static variables.</p> </li> <li> <code>get_tok_precedence</code>             \u2013              <p>Get the precedence of the pending binary operator token.</p> </li> <li> <code>parse</code>             \u2013              <p>Parse the input code.</p> </li> <li> <code>parse_bin_op_rhs</code>             \u2013              <p>Parse a binary expression.</p> </li> <li> <code>parse_block</code>             \u2013              <p>Parse a block of nodes.</p> </li> <li> <code>parse_expression</code>             \u2013              <p>Parse an expression.</p> </li> <li> <code>parse_extern</code>             \u2013              <p>Parse the extern expression.</p> </li> <li> <code>parse_extern_prototype</code>             \u2013              <p>Parse an extern prototype expression.</p> </li> <li> <code>parse_float_expr</code>             \u2013              <p>Parse the number expression.</p> </li> <li> <code>parse_for_stmt</code>             \u2013              <p>Parse the <code>for</code> expression.</p> </li> <li> <code>parse_function</code>             \u2013              <p>Parse the function definition expression.</p> </li> <li> <code>parse_identifier_expr</code>             \u2013              <p>Parse the identifier expression.</p> </li> <li> <code>parse_if_stmt</code>             \u2013              <p>Parse the <code>if</code> expression.</p> </li> <li> <code>parse_paren_expr</code>             \u2013              <p>Parse the parenthesis expression.</p> </li> <li> <code>parse_primary</code>             \u2013              <p>Parse the primary expression.</p> </li> <li> <code>parse_prototype</code>             \u2013              <p>Parse the prototype expression.</p> </li> <li> <code>parse_return_function</code>             \u2013              <p>Parse the return expression.</p> </li> <li> <code>parse_unary</code>             \u2013              <p>Parse a unary expression.</p> </li> <li> <code>parse_var_expr</code>             \u2013              <p>Parse the <code>var</code> declaration expression.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def __init__(self, tokens: TokenList = TokenList([])) -&gt; None:\n    \"\"\"Instantiate the Parser object.\"\"\"\n    self.bin_op_precedence: dict[str, int] = {\n        \"=\": 2,\n        \"&lt;\": 10,\n        \"&gt;\": 10,\n        \"+\": 20,\n        \"-\": 20,\n        \"*\": 40,\n    }\n    self.indent_level: int = 0\n    # note: it is useful to assign an initial token list here\n    #       mainly for tests\n    self.tokens: TokenList = tokens\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.clean","title":"clean","text":"<pre><code>clean() -&gt; None\n</code></pre> <p>Reset the Parser static variables.</p> Source code in <code>src/arx/parser.py</code> <pre><code>def clean(self) -&gt; None:\n    \"\"\"Reset the Parser static variables.\"\"\"\n    self.indent_level = 0\n    self.tokens: TokenList = TokenList([])\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.get_tok_precedence","title":"get_tok_precedence","text":"<pre><code>get_tok_precedence() -&gt; int\n</code></pre> <p>Get the precedence of the pending binary operator token.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The token precedence.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def get_tok_precedence(self) -&gt; int:\n    \"\"\"\n    Get the precedence of the pending binary operator token.\n\n    Returns\n    -------\n    int\n        The token precedence.\n    \"\"\"\n    return self.bin_op_precedence.get(self.tokens.cur_tok.value, -1)\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse","title":"parse","text":"<pre><code>parse(\n    tokens: TokenList, module_name: str = \"main\"\n) -&gt; Block\n</code></pre> <p>Parse the input code.</p> <p>Returns:</p> <ul> <li> <code>Block</code>           \u2013            <p>The parsed abstract syntax tree (AST), or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse(\n    self, tokens: TokenList, module_name: str = \"main\"\n) -&gt; astx.Block:\n    \"\"\"\n    Parse the input code.\n\n    Returns\n    -------\n    astx.Block\n        The parsed abstract syntax tree (AST), or None if parsing fails.\n    \"\"\"\n    self.clean()\n    self.tokens = tokens\n\n    tree: astx.Module = astx.Module(module_name)\n    self.tokens.get_next_token()\n\n    if self.tokens.cur_tok.kind == TokenKind.not_initialized:\n        self.tokens.get_next_token()\n\n    while True:\n        if self.tokens.cur_tok.kind == TokenKind.eof:\n            break\n        elif self.tokens.cur_tok == Token(\n            kind=TokenKind.operator, value=\";\"\n        ):\n            # ignore top-level semicolons.\n            self.tokens.get_next_token()\n        elif self.tokens.cur_tok.kind == TokenKind.kw_function:\n            tree.nodes.append(self.parse_function())\n        elif self.tokens.cur_tok.kind == TokenKind.kw_extern:\n            tree.nodes.append(self.parse_extern())\n        else:\n            tree.nodes.append(self.parse_expression())\n\n    return tree\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_bin_op_rhs","title":"parse_bin_op_rhs","text":"<pre><code>parse_bin_op_rhs(expr_prec: int, lhs: Expr) -&gt; Expr\n</code></pre> <p>Parse a binary expression.</p> <p>Parameters:</p> <ul> <li> <code>expr_prec</code>               (<code>int</code>)           \u2013            <p>Expression precedence (deprecated).</p> </li> <li> <code>lhs</code>               (<code>Expr</code>)           \u2013            <p>Left-hand side expression.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Expr</code>           \u2013            <p>The parsed binary expression, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_bin_op_rhs(\n    self,\n    expr_prec: int,\n    lhs: astx.Expr,\n) -&gt; astx.Expr:\n    \"\"\"\n    Parse a binary expression.\n\n    Parameters\n    ----------\n    expr_prec : int\n        Expression precedence (deprecated).\n    lhs : astx.Expr\n        Left-hand side expression.\n\n    Returns\n    -------\n    astx.Expr\n        The parsed binary expression, or None if parsing fails.\n    \"\"\"\n    # If this is a binop, find its precedence. #\n    while True:\n        cur_prec: int = self.get_tok_precedence()\n\n        # If this is a binop that binds at least as tightly as the current\n        # binop, consume it, otherwise we are done.\n        if cur_prec &lt; expr_prec:\n            return lhs\n\n        # Okay, we know this is a binop.\n        bin_op: str = self.tokens.cur_tok.value\n        bin_loc: SourceLocation = self.tokens.cur_tok.location\n        self.tokens.get_next_token()  # eat binop\n\n        # Parse the unary expression after the binary operator.\n        rhs: astx.Expr = self.parse_unary()\n\n        # If BinOp binds less tightly with rhs than the operator after\n        # rhs, let the pending operator take rhs as its lhs\n        next_prec: int = self.get_tok_precedence()\n        if cur_prec &lt; next_prec:\n            rhs = self.parse_bin_op_rhs(cur_prec + 1, rhs)\n\n        # Merge lhs/rhs.\n        lhs = astx.BinaryOp(\n            bin_op,\n            cast(astx.DataType, lhs),\n            cast(astx.DataType, rhs),\n            loc=bin_loc,\n        )\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_block","title":"parse_block","text":"<pre><code>parse_block() -&gt; Block\n</code></pre> <p>Parse a block of nodes.</p> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_block(self) -&gt; astx.Block:\n    \"\"\"Parse a block of nodes.\"\"\"\n    cur_indent: int = self.tokens.cur_tok.value\n\n    self.tokens.get_next_token()  # eat indentation\n\n    block: astx.Block = astx.Block()\n\n    if cur_indent == self.indent_level:\n        raise ParserException(\"There is no new block to be parsed.\")\n\n    if cur_indent &gt; self.indent_level:\n        self.indent_level = cur_indent\n\n        while expr := self.parse_expression():\n            block.nodes.append(expr)\n            # if isinstance(expr, astx.IfStmt):\n            #     breakpoint()\n            if self.tokens.cur_tok.kind != TokenKind.indent:\n                break\n\n            new_indent = self.tokens.cur_tok.value\n\n            if new_indent &lt; cur_indent:\n                break\n\n            if new_indent &gt; cur_indent:\n                raise ParserException(\"Indentation not allowed here.\")\n\n            self.tokens.get_next_token()  # eat indentation\n\n    self.indent_level -= INDENT_SIZE\n    return block\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_expression","title":"parse_expression","text":"<pre><code>parse_expression() -&gt; Expr\n</code></pre> <p>Parse an expression.</p> <p>Returns:</p> <ul> <li> <code>Expr</code>           \u2013            <p>The parsed expression, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_expression(self) -&gt; astx.Expr:\n    \"\"\"\n    Parse an expression.\n\n    Returns\n    -------\n    astx.Expr\n        The parsed expression, or None if parsing fails.\n    \"\"\"\n    lhs: astx.Expr = self.parse_unary()\n    return self.parse_bin_op_rhs(0, lhs)\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_extern","title":"parse_extern","text":"<pre><code>parse_extern() -&gt; FunctionPrototype\n</code></pre> <p>Parse the extern expression.</p> <p>Returns:</p> <ul> <li> <code>FunctionPrototype</code>           \u2013            <p>The parsed extern expression as a prototype, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_extern(self) -&gt; astx.FunctionPrototype:\n    \"\"\"\n    Parse the extern expression.\n\n    Returns\n    -------\n    astx.FunctionPrototype\n        The parsed extern expression as a prototype, or None if parsing\n        fails.\n    \"\"\"\n    self.tokens.get_next_token()  # eat extern.\n    return self.parse_extern_prototype()\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_extern_prototype","title":"parse_extern_prototype","text":"<pre><code>parse_extern_prototype() -&gt; FunctionPrototype\n</code></pre> <p>Parse an extern prototype expression.</p> <p>Returns:</p> <ul> <li> <code>FunctionPrototype</code>           \u2013            <p>The parsed extern prototype, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_extern_prototype(self) -&gt; astx.FunctionPrototype:\n    \"\"\"\n    Parse an extern prototype expression.\n\n    Returns\n    -------\n    astx.FunctionPrototype\n        The parsed extern prototype, or None if parsing fails.\n    \"\"\"\n    fn_name: str\n    var_typing: astx.DataType\n    ret_typing: astx.DataType\n    identifier_name: str\n\n    cur_loc: SourceLocation\n    fn_loc = self.tokens.cur_tok.location\n\n    if self.tokens.cur_tok.kind == TokenKind.identifier:\n        fn_name = self.tokens.cur_tok.value\n        self.tokens.get_next_token()\n    else:\n        raise Exception(\"Parser: Expected function name in prototype\")\n\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\"(\"):\n        raise Exception(\"Parser: Expected '(' in the function definition.\")\n\n    args = astx.Arguments()\n    while self.tokens.get_next_token().kind == TokenKind.identifier:\n        # note: this is a workaround\n        identifier_name = self.tokens.cur_tok.value\n        cur_loc = self.tokens.cur_tok.location\n\n        # TODO: type should be defined dynamic\n        var_typing = astx.Float32()\n\n        args.append(\n            astx.Argument(identifier_name, var_typing, loc=cur_loc)\n        )\n\n        if self.tokens.get_next_token() != Token(\n            kind=TokenKind.operator, value=\",\"\n        ):\n            break\n\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\")\"):\n        raise Exception(\"Parser: Expected ')' in the function definition.\")\n\n    # success. #\n    self.tokens.get_next_token()  # eat ')'.\n\n    ret_typing = astx.Float32()\n\n    return astx.FunctionPrototype(fn_name, args, ret_typing, loc=fn_loc)\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_float_expr","title":"parse_float_expr","text":"<pre><code>parse_float_expr() -&gt; LiteralFloat32\n</code></pre> <p>Parse the number expression.</p> <p>Returns:</p> <ul> <li> <code>LiteralFloat32</code>           \u2013            <p>The parsed float expression.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_float_expr(self) -&gt; astx.LiteralFloat32:\n    \"\"\"\n    Parse the number expression.\n\n    Returns\n    -------\n    astx.LiteralFloat32\n        The parsed float expression.\n    \"\"\"\n    result = astx.LiteralFloat32(self.tokens.cur_tok.value)\n    self.tokens.get_next_token()  # consume the number\n    return result\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_for_stmt","title":"parse_for_stmt","text":"<pre><code>parse_for_stmt() -&gt; ForRangeLoopStmt\n</code></pre> <p>Parse the <code>for</code> expression.</p> <p>Returns:</p> <ul> <li> <code>ForRangeLoopStmt</code>           \u2013            <p>The parsed <code>for</code> expression, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_for_stmt(self) -&gt; astx.ForRangeLoopStmt:\n    \"\"\"\n    Parse the `for` expression.\n\n    Returns\n    -------\n    astx.ForRangeLoopStmt\n        The parsed `for` expression, or None if parsing fails.\n    \"\"\"\n    self.tokens.get_next_token()  # eat the for.\n\n    if self.tokens.cur_tok.kind != TokenKind.identifier:\n        raise Exception(\"Parser: Expected identifier after for\")\n\n    # TODO: type should be defined dynamic\n    inline_var = astx.InlineVariableDeclaration(\n        self.tokens.cur_tok.value,\n        astx.Float32(),\n    )\n    self.tokens.get_next_token()  # eat identifier.\n\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\"=\"):\n        raise Exception(\"Parser: Expected '=' after for\")\n    self.tokens.get_next_token()  # eat '='.\n\n    start: astx.Expr = self.parse_expression()\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\",\"):\n        raise Exception(\"Parser: Expected ',' after for start value\")\n    self.tokens.get_next_token()\n\n    end: astx.Expr = self.parse_expression()\n\n    # The step value is optional\n    if self.tokens.cur_tok == Token(kind=TokenKind.operator, value=\",\"):\n        self.tokens.get_next_token()\n        step = self.parse_expression()\n    else:\n        step = astx.LiteralFloat32(1.0)\n\n    if self.tokens.cur_tok.kind != TokenKind.kw_in:  # type: ignore\n        raise Exception(\"Parser: Expected 'in' after for\")\n    self.tokens.get_next_token()  # eat 'in'.\n\n    body_block: astx.Block = astx.Block()\n    body_block.nodes.append(self.parse_expression())\n    return astx.ForRangeLoopStmt(inline_var, start, end, step, body_block)\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_function","title":"parse_function","text":"<pre><code>parse_function() -&gt; FunctionDef\n</code></pre> <p>Parse the function definition expression.</p> <p>Returns:</p> <ul> <li> <code>FunctionDef</code>           \u2013            <p>The parsed function definition, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_function(self) -&gt; astx.FunctionDef:\n    \"\"\"\n    Parse the function definition expression.\n\n    Returns\n    -------\n    astx.FunctionDef\n        The parsed function definition, or None if parsing fails.\n    \"\"\"\n    self.tokens.get_next_token()  # eat function.\n    proto: astx.FunctionPrototype = self.parse_prototype()\n    return astx.FunctionDef(proto, self.parse_block())\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_identifier_expr","title":"parse_identifier_expr","text":"<pre><code>parse_identifier_expr() -&gt; Expr\n</code></pre> <p>Parse the identifier expression.</p> <p>Returns:</p> <ul> <li> <code>Expr</code>           \u2013            <p>The parsed expression, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_identifier_expr(self) -&gt; astx.Expr:\n    \"\"\"\n    Parse the identifier expression.\n\n    Returns\n    -------\n    astx.Expr\n        The parsed expression, or None if parsing fails.\n    \"\"\"\n    id_name: str = self.tokens.cur_tok.value\n\n    id_loc: SourceLocation = self.tokens.cur_tok.location\n\n    self.tokens.get_next_token()  # eat identifier.\n\n    # TODO: var type should be dynamic\n    var_type = astx.Float32()\n\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\"(\"):\n        # Simple variable ref, not a function call\n        # todo: we need to get the variable type from a specific scope\n        return astx.Variable(id_name, var_type, loc=id_loc)\n\n    # Call.\n    self.tokens.get_next_token()  # eat (\n    args: list[astx.DataType] = []\n\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\")\"):\n        while True:\n            args.append(cast(astx.DataType, self.parse_expression()))\n\n            if self.tokens.cur_tok == Token(\n                kind=TokenKind.operator, value=\")\"\n            ):\n                break\n\n            if self.tokens.cur_tok != Token(\n                kind=TokenKind.operator, value=\",\"\n            ):\n                raise Exception(\n                    \"Parser: Expected ')' or ',' in argument list\"\n                )\n            self.tokens.get_next_token()\n\n    # Eat the ')'.\n    self.tokens.get_next_token()\n\n    return astx.FunctionCall(id_name, args, loc=id_loc)\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_if_stmt","title":"parse_if_stmt","text":"<pre><code>parse_if_stmt() -&gt; IfStmt\n</code></pre> <p>Parse the <code>if</code> expression.</p> <p>Returns:</p> <ul> <li> <code>IfStmt</code>           \u2013            <p>The parsed <code>if</code> expression, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_if_stmt(self) -&gt; astx.IfStmt:\n    \"\"\"\n    Parse the `if` expression.\n\n    Returns\n    -------\n    astx.IfStmt\n        The parsed `if` expression, or None if parsing fails.\n    \"\"\"\n    if_loc: SourceLocation = self.tokens.cur_tok.location\n\n    self.tokens.get_next_token()  # eat the if.\n\n    cond: astx.Expr = self.parse_expression()\n\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\":\"):\n        msg = (\n            \"Parser: `if` statement expected ':', received: '\"\n            + str(self.tokens.cur_tok)\n            + \"'.\"\n        )\n        raise Exception(msg)\n\n    self.tokens.get_next_token()  # eat the ':'\n\n    then_block: astx.Block = astx.Block()\n    else_block: astx.Block = astx.Block()\n\n    then_block = self.parse_block()\n\n    if self.tokens.cur_tok.kind == TokenKind.indent:\n        self.tokens.get_next_token()  # eat the indentation\n\n    if self.tokens.cur_tok.kind == TokenKind.kw_else:\n        self.tokens.get_next_token()  # eat the else token\n\n        if self.tokens.cur_tok != Token(\n            kind=TokenKind.operator, value=\":\"\n        ):\n            msg = (\n                \"Parser: `else` statement expected ':', received: '\"\n                + str(self.tokens.cur_tok)\n                + \"'.\"\n            )\n            raise Exception(msg)\n\n        self.tokens.get_next_token()  # eat the ':'\n        else_block = self.parse_block()\n\n    return astx.IfStmt(cond, then_block, else_block, loc=if_loc)\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_paren_expr","title":"parse_paren_expr","text":"<pre><code>parse_paren_expr() -&gt; Expr\n</code></pre> <p>Parse the parenthesis expression.</p> <p>Returns:</p> <ul> <li> <code>Expr</code>           \u2013            <p>The parsed expression.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_paren_expr(self) -&gt; astx.Expr:\n    \"\"\"\n    Parse the parenthesis expression.\n\n    Returns\n    -------\n    astx.Expr\n        The parsed expression.\n    \"\"\"\n    self.tokens.get_next_token()  # eat (.\n    expr = self.parse_expression()\n\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\")\"):\n        raise Exception(\"Parser: Expected ')'\")\n    self.tokens.get_next_token()  # eat ).\n    return expr\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_primary","title":"parse_primary","text":"<pre><code>parse_primary() -&gt; AST\n</code></pre> <p>Parse the primary expression.</p> <p>Returns:</p> <ul> <li> <code>Expr</code>           \u2013            <p>The parsed primary expression, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_primary(self) -&gt; astx.AST:\n    \"\"\"\n    Parse the primary expression.\n\n    Returns\n    -------\n    astx.Expr\n        The parsed primary expression, or None if parsing fails.\n    \"\"\"\n    if self.tokens.cur_tok.kind == TokenKind.identifier:\n        return self.parse_identifier_expr()\n    elif self.tokens.cur_tok.kind == TokenKind.float_literal:\n        return self.parse_float_expr()\n    elif self.tokens.cur_tok == Token(kind=TokenKind.operator, value=\"(\"):\n        return self.parse_paren_expr()\n    elif self.tokens.cur_tok.kind == TokenKind.kw_if:\n        return self.parse_if_stmt()\n    elif self.tokens.cur_tok.kind == TokenKind.kw_for:\n        return self.parse_for_stmt()\n    elif self.tokens.cur_tok.kind == TokenKind.kw_var:\n        return self.parse_var_expr()\n    elif self.tokens.cur_tok == Token(kind=TokenKind.operator, value=\";\"):\n        # ignore top-level semicolons.\n        self.tokens.get_next_token()  # eat `;`\n        return self.parse_primary()\n    elif self.tokens.cur_tok.kind == TokenKind.kw_return:\n        return self.parse_return_function()\n    elif self.tokens.cur_tok.kind == TokenKind.indent:\n        return self.parse_block()\n    else:\n        msg: str = (\n            \"Parser: Unknown token when expecting an expression:\"\n            f\"'{self.tokens.cur_tok.get_name()}'.\"\n        )\n        self.tokens.get_next_token()  # eat unknown token\n        raise Exception(msg)\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_prototype","title":"parse_prototype","text":"<pre><code>parse_prototype() -&gt; FunctionPrototype\n</code></pre> <p>Parse the prototype expression.</p> <p>Returns:</p> <ul> <li> <code>FunctionPrototype</code>           \u2013            <p>The parsed prototype, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_prototype(self) -&gt; astx.FunctionPrototype:\n    \"\"\"\n    Parse the prototype expression.\n\n    Returns\n    -------\n    astx.FunctionPrototype\n        The parsed prototype, or None if parsing fails.\n    \"\"\"\n    fn_name: str\n    var_typing: astx.DataType\n    ret_typing: astx.DataType\n    identifier_name: str\n\n    cur_loc: SourceLocation\n    fn_loc: SourceLocation = self.tokens.cur_tok.location\n\n    if self.tokens.cur_tok.kind == TokenKind.identifier:\n        fn_name = self.tokens.cur_tok.value\n        self.tokens.get_next_token()\n    else:\n        raise Exception(\"Parser: Expected function name in prototype\")\n\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\"(\"):\n        raise Exception(\"Parser: Expected '(' in the function definition.\")\n\n    args = astx.Arguments()\n    while self.tokens.get_next_token().kind == TokenKind.identifier:\n        # note: this is a workaround\n        identifier_name = self.tokens.cur_tok.value\n        cur_loc = self.tokens.cur_tok.location\n\n        # TODO: type should be dynamic\n        var_typing = astx.Float32()\n\n        args.append(\n            astx.Argument(identifier_name, var_typing, loc=cur_loc)\n        )\n\n        if self.tokens.get_next_token() != Token(\n            kind=TokenKind.operator, value=\",\"\n        ):\n            break\n\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\")\"):\n        raise Exception(\"Parser: Expected ')' in the function definition.\")\n\n    # success. #\n    self.tokens.get_next_token()  # eat ')'.\n\n    # TODO: type should be dynamic\n    ret_typing = astx.Float32()\n\n    if self.tokens.cur_tok != Token(kind=TokenKind.operator, value=\":\"):\n        raise Exception(\"Parser: Expected ':' in the function definition\")\n\n    self.tokens.get_next_token()  # eat ':'.\n\n    return astx.FunctionPrototype(fn_name, args, ret_typing, loc=fn_loc)\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_return_function","title":"parse_return_function","text":"<pre><code>parse_return_function() -&gt; FunctionReturn\n</code></pre> <p>Parse the return expression.</p> <p>Returns:</p> <ul> <li> <code>FunctionReturn</code>           \u2013            <p>The parsed return expression, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_return_function(self) -&gt; astx.FunctionReturn:\n    \"\"\"\n    Parse the return expression.\n\n    Returns\n    -------\n    astx.FunctionReturn\n        The parsed return expression, or None if parsing fails.\n    \"\"\"\n    self.tokens.get_next_token()  # eat return\n    return astx.FunctionReturn(\n        cast(astx.DataType, self.parse_expression())\n    )\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_unary","title":"parse_unary","text":"<pre><code>parse_unary() -&gt; UnaryOp\n</code></pre> <p>Parse a unary expression.</p> <p>Returns:</p> <ul> <li> <code>Expr</code>           \u2013            <p>The parsed unary expression, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_unary(self) -&gt; astx.UnaryOp:\n    \"\"\"\n    Parse a unary expression.\n\n    Returns\n    -------\n    astx.Expr\n        The parsed unary expression, or None if parsing fails.\n    \"\"\"\n    # If the current token is not an operator, it must be a primary expr.\n    if (\n        self.tokens.cur_tok.kind != TokenKind.operator\n        or self.tokens.cur_tok.value in (\"(\", \",\")\n    ):\n        return cast(astx.UnaryOp, self.parse_primary())\n\n    # If this is a unary operator, read it.\n    op_code: str = self.tokens.cur_tok.value\n    self.tokens.get_next_token()\n    operand = self.parse_unary()\n    return astx.UnaryOp(op_code, operand)\n</code></pre>"},{"location":"api/parser/#arx.parser.Parser.parse_var_expr","title":"parse_var_expr","text":"<pre><code>parse_var_expr() -&gt; VariableDeclaration\n</code></pre> <p>Parse the <code>var</code> declaration expression.</p> <p>Returns:</p> <ul> <li> <code>VariableDeclaration</code>           \u2013            <p>The parsed <code>var</code> expression, or None if parsing fails.</p> </li> </ul> Source code in <code>src/arx/parser.py</code> <pre><code>def parse_var_expr(self) -&gt; astx.VariableDeclaration:\n    \"\"\"\n    Parse the `var` declaration expression.\n\n    Returns\n    -------\n    astx.VariableDeclaration\n        The parsed `var` expression, or None if parsing fails.\n    \"\"\"\n    self.tokens.get_next_token()  # eat the var.\n\n    var_names: list[tuple[str, astx.Expr]] = []\n\n    # At least one variable name is required. #\n    if self.tokens.cur_tok.kind != TokenKind.identifier:\n        raise Exception(\"Parser: Expected identifier after var\")\n\n    while True:\n        name: str = self.tokens.cur_tok.value\n        self.tokens.get_next_token()  # eat identifier.\n\n        # Read the optional initializer. #\n        Init: astx.Expr\n        if self.tokens.cur_tok == Token(\n            kind=TokenKind.operator, value=\"=\"\n        ):\n            self.tokens.get_next_token()  # eat the '='.\n\n            Init = self.parse_expression()\n        else:\n            Init = astx.LiteralFloat32(0.0)\n\n        var_names.append((name, Init))\n\n        # end of var list, exit loop. #\n        if self.tokens.cur_tok != Token(\n            kind=TokenKind.operator, value=\",\"\n        ):\n            break\n        self.tokens.get_next_token()  # eat the ','.\n\n        if self.tokens.cur_tok.kind != TokenKind.identifier:\n            raise Exception(\"Parser: Expected identifier list after var\")\n\n    # At this point, we have to have 'in'. #\n    if self.tokens.cur_tok.kind != TokenKind.kw_in:  # type: ignore\n        raise Exception(\"Parser: Expected 'in' keyword after 'var'\")\n    self.tokens.get_next_token()  # eat 'in'.\n\n    body: astx.Expr = self.parse_expression()\n    return astx.VariableDeclaration(var_names, \"float\", body)\n</code></pre>"},{"location":"api/semantic/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> semantic","text":""},{"location":"api/semantic/#arx.semantic","title":"semantic","text":"<p>Semantic analysis module.</p>"}]}